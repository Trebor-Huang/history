\chapter{前言}\label{intro}
2020年12月, Peter Scholze发布了\href{https://xenaproject.wordpress.com/2020/12/05/liquid-tensor-experiment/}{一项挑战}~\cite{scholze:2020:liquid}.
在他的凝聚态数学前沿研究中有一条技术性定理, 对于这个领域有
至关重要的作用：
\begin{theorem}[Clausen, Scholze]
设 \(0 < p' < p \le 1\) 为实数, 令 \(S\) 为投射有限集,
\(V\) 为 \(p\)-Banach 空间. 记 \(\mathcal M_{p'}(S)\)
为 \(S\) 上的 \(p'\)-测度构成的空间. 那么对于 \(i \ge 1\) 有
\[\mathrm{Ext}_{\mathsf{Cond}(\mathsf{Ab})}^i(
  \mathcal M_{p'}(S), V
) = 0.\]
\end{theorem}
Scholze希望这条定理的证明可以被完全严格形式化, 并且通过
计算机的检查. 2022年7月, Lean
社区\href{https://leanprover-community.github.io/blog/posts/lte-final/}{宣布}这个挑战正式完成.
换句话说, 即使是数学最尖端的结论, 也可以在一年半的时间内
被转化成计算机可以理解并验证的代码.
这种成就是如何达成的呢? 答案是Lean的类型论.

在类型论中, 一切数学对象的含义都由它们从属的类型决定.
如类型 \(\mathbb N\) 的元素是自然数, 而类型 \(\alpha \times \beta\)
的元素是有序对, 类型 \(\alpha \to\beta\) 的元素
是映射, 等等. 而这些类型可以相互组合, 表达出复杂的含义,
这使得类型论有能力作为数学的基础, 与集合论的地位类似.
另一方面, 计算机科学中也有利用类型描述程序的传统. 因此, 类型论
可以看作是数学与计算机之间的桥梁. 这也使得计算机定理
验证成为了有可行性的工作: 证明可以写成计算机能解析的语言,
并且交由计算机验证正确性. 传统的使用一阶逻辑与集合论数学
基础中, 一个初等的定理也可能需要冗长的说明才能完全
严格的写出来, 因此尽管理论上可能, 实操上却非常困难.
类型论不仅可以验证数学定理. 现在, 类型论正广泛用于
验证各种需要低出错率的软硬件, 如军事、医用、宇航电子仪器等
设计无误.

这篇文章的主要目的是以历史作为连贯的主线将类型论的知识
串联在一起, 为中文学习者提供些微的参考价值. 同时, 文章中
介绍各个领域时都会提及其中优秀的参考书目或者其他文献资料,
供希望进一步了解的读者阅读. 对于一些没有标准翻译的名词, 会
在括号中附上英文名称.

文章不要求任何类型论的前置知识, 并且尽量避免范畴论知识的
使用, 但是会援引一般数学中的许多例子. 同时, 每一节的内容
相对独立, 因此如果某一部分使用的前置知识较多, 读者可以直接
跳过, 不影响后续阅读. 在使用范畴论知识时, 会使用如下的图标
标示难度：
\begin{center}
\begin{tikzpicture}
\foreach \k in {1,2,3,4} {
  \node at ({2*\k},0) {\berryglow{\k}};
}
\end{tikzpicture}
\end{center}
草莓籽表示不需要范畴论知识, 或者只需要文内已经提到的知识.
红色草莓表示需要读者对基础的范畴论定义有熟悉度.
金草莓意味着读者需要掌握范畴之间的常用操作(米田引理等).
月莓图标表示读者需要对意象论的各种构造有直观理解.

在文章写作过程中, 类型论社区提供了巨大的帮助, 包括查找一些
事实错误, 提供优秀的参考资料, 修改措辞等等. 特别地,
\href{https://ncatlab.org/}{\(n\)Lab} 上记有许多令人
醍醐灌顶的观点, 但是由于不是期刊书籍, 它的功劳很难以
学术通用的形式得到应有的承认.

这篇文章按照 \href{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}{CC BY-NC-SA 4.0} 协议发布.

\section{什么是类型论?}
从最表层的角度说, 类型论研究的是对象和它们的类型之间的
相互作用. 比如说 \(1\) 的类型是 \(\mathbb N\),
而函数的类型是 \(\mathbb N \to \mathbb N\);
一个泛函的类型则可能是
\((\mathbb R \to \mathbb R) \to \mathbb R\).
大部分类型论的介绍都会采取同一个思路：
一套类型系统\footnote{类型系统也叫做类型论,
而上面说的是类型论这门学科, 就像拓扑这门学科研究的
是拓扑这种数学对象一样.}%
就是一组规则的集合, 我们应用这些规则推导一些结论.
这些结论被称为\textbf{断言}(judgement). 譬如
“\(1+1=2\)” 就可以是某个类型论中的断言. 而类型论
就是研究这些断言的学科.

但是纵观类型论120年的历史, 这其实是一个有失偏颇的
概括. 它只注意到了类型论的\textbf{语法} (syntax), 或者称为
“语形”的研究. 而语法与\textbf{语义} (semantics) 是
分不开的. 在这里, 我提出这篇论文的中心：
\slogan{类型论是语法与语义研究的对立统一.}
这就将问题拆分为三个部分：
\begin{itemize}
\item (\ref{intro:syntax}~节) 什么是语法?
\item (\ref{intro:semantics}~节) 什么是语义?
\item (\ref{intro:unity}~节) 二者的研究是如何对立统一的?
\end{itemize}
这一章剩下的部分将会简要地从当代视角解释这些问题,
读者也可以直接跳过阅读下一章.
类型论不仅局限于数学, 它在计算机科学与哲学中都有重要
的地位. 因此这篇文章会尽可能多地谈及各方面的例子,
以让读者多了解不同学科视角下的思想.

\section{朴素的语法}\label{intro:syntax}

什么是语法? 最朴素, 也是人们最初的理解, 就是从所有的字符串
(字符串就是某个固定的字母表中的符号组成的有限长的列表)中
选出一个子集, 规定为 “符合语法” 的. 譬如我规定字母表
是 \(\{0,1,2,3,4,5,6,7,8,9,+,\times\}\), 然后写
出一些规则, 使得 \(1 + 3 \times 25\) 是符合语法的,
而 \(++3\times 03\) 不是.

这些规则一般是这样：
\[
\frac{(n \in \{0,1,\dots,9\})}{n~\textrm{number}}\quad
\frac{n~\textrm{number}\quad (m \in \{1,\dots,9\})}{mn~\textrm{number}}
\]
\[
\frac{n~\text{number}}{n~\text{valid}}\quad
\frac{n~\text{valid}\quad m~\text{valid}}{n+m~\text{valid}}\quad
\frac{n~\text{valid}\quad m~\text{valid}}{n\times m~\text{valid}}
\]

这种写法来自逻辑学的传统, 上面是前提, 下面是结论.
如果用数学中更常见的写法, 就是譬如
“如果 \(n\) 和 \(m\) 是符合语法的表达式, 那么
\(n \times m\) 也是符合语法的表达式.”
并且所有符合语法的表达式是在这些规则下封闭的最小集合.

这种原始的语法, 优点在于非常简单. 如果我们希望创造一种
数学基础, 我们当然不希望定义这个基础的时候就用到大量的
数学概念. 字符串和它们的拼接 ------ 这再简单不过了, 任何
人都能够确信自己可以正确理解并操作. 类型论创始时正是为了
解决 Russell 悖论引起的基础危机, 所以这一点尤其重要.

然而这种语法的缺陷在正式应用时就会立刻体现出来. 譬如在处理
变量的时候： 我们都很清楚 \(\int x \,\mathrm dx\) 中
没有\textbf{自由变量}, 只有\textbf{束缚变量} \(x\). 因此它
写成 \(\int y \,\mathrm dy\) 是完全一样的. 同样的道理,
如果 \(f(x) = \int_0^1 xy \,\mathrm dy\), 那么计算
\(f(y^2)\) 的时候, 我们不能简单的代入
\[f(y^2) \stackrel?= \int_0^1 y^2 \cdot y\,\mathrm dy.\]
正确的做法是先将束缚变量 \(y\) 改成另一个名字, 再代入.
把数学表达式作为字符串处理时, 这种问题是尤其头疼的. 更不用
说还需要证明每个字符串至多有一种解读的方式, 等等.

然而这些问题都是一些鸡毛蒜皮的小事, 都可以通过机械而繁琐
的步骤处理. 在度过基础危机时期之后,
我们理应放下过于谨慎的态度. 对于形式系统的研究, 我们绝大
部分的精力都不应该放在处理这种事情上, 而应该讨论一些真正
重要的问题： 这个系统有没有矛盾? 这个系统能不能证明这些重
要的定理? 这些问题, 与用字符串时产生的这些技术细节是不相干的.

那么, 我们应当换一个视角看这个问题： 字符串本身并不是语法.
\emph{它只是表示语法的一种方式}. Klein 群并不是
四个矩阵; 这四个矩阵只是表示这个群的一种方式. 我们的实数
并不是Cauchy收敛的数列的等价类; 这些等价类只是编码实数
的一种方式. 对于语法来说, 我们感兴趣的并不是这些字符串的性质,
而是这些字符串表示的东西. 换言之, 我们可以认为存在\footnote{当然,
一个数学对象是否“存在”是一个数学哲学问题, 这里不过多讨论.}一个
“理想”的语法, 而我们使用字符串或者其他什么方式描述的
只是表示这种语法的一种方式, 我们只不过没有更好的办法描述
这种理想的语法而已. 这就引出了\textbf{客观语法}的概念.

\section{客观逻辑与主观逻辑}
这两个概念源于 Hegel. Hegel 认为逻辑分为两种.
其中主观逻辑类似于我们数学中称的逻辑, 处理的是重言式
而没有实质内容. 而客观逻辑则处理的是概念的发生学, 把
哲学上 (如 Kant) 对概念的划分从任意武断的变为理性
必然的.\footnote{笔者对哲学不完全了解, 如果有不妥请
尽管指出.} 我们可以把客观逻辑的研究中遇到的问题编码成
主观逻辑可以处理的问题, 进而用主观逻辑进行推导; 但是
由于主观逻辑自身的局限性, 这些终究只是一种编码.
(与之相对地, Russell等人认为仅仅使用形式逻辑就可以
研究一切的哲学问题, 这开创了分析哲学学派.)

数学家 Lawvere 将这两个概念拿到了数学中来. 他认为
主观逻辑是客观逻辑的一部分, 主观逻辑反映了客观逻辑,
并且部分指导客观逻辑的构造.
\begin{quotation}
五十年前, 源于几何学的需求, 范畴论创造了譬如
伴随函子、意象、纤维化、闭范畴、2-范畴等等的事物.
这些事物是为了帮助阐明一些复杂但并非随意构造的概念,
以及这些概念之间的相互作用; 这些概念产生于对空间和
数量的研究的需要. [...] 如果我们把[上面这句话]其中的
“空间和数量” 替换成 “任何一项严肃的研究”, 那么这就是我
姑且对\textbf{客观逻辑}的定义.~\cite{lawvere:1994:objective}
\end{quotation}
Lawvere 认为, 范畴论就是客观逻辑的一个数学模型. 我们
在数学中的定义--定理--证明过程都是由主观逻辑 (即形式逻辑)
主导的, 但是这些定义的动机、定理的直观、证明的思路, 都是
来自于客观逻辑. 主观逻辑不能刻画全部的客观逻辑, 而只是其
一部分, 并且承担着指导作用, 正如铁轨指导火车的运行. 同时,
我们交流时不能直接交流客观逻辑中的理念, 而只能先将它们编码
成主观逻辑中的命题.

回到语法上来. 我们自然可以如上一节所举的例子那样定义
一套语法, 但是这一套语法背后反映的实际上是我们对于四则
运算的概念. 因此譬如括号匹配, 优先级等等概念, 实际上
都是这种具体的编码 --- 也就是\textbf{主观语法} ---
中的细节. 而这个主观语法所意图反映的概念才是我们真正
希望研究的, 也即\textbf{客观语法}. 这与下面提到的语义
的概念有所区别, \hyperref[intro:semantics]{下一节}介绍
语义时再详细阐述. 与主客观逻辑
类似, 客观的语法是不能落脚到计算机上来的, 因此主观语法
仍然是有必要的. 对于主观语法和客观语法的研究, 构成了对立统一.

作为 Lawvere 思想的一种具体化, 客观语法可以由范畴论
刻画, 特别地, 由意象 (topos) 刻画. 这一思想 (据笔者考证)
是由 Jonathan Sterling 提出的. 我们在之后的章节里
会逐步介绍具体的细节.
当代的类型论研究重点已经逐渐从主观的语法转移到客观的语法
上来. 正如 Sterling 所说：

\begin{quotation}
这篇学位论文立足于一项重要的观察：
类型论中的定理可以用一种在范畴的等价下不变的方式叙述;
因此, 我们没有必要过于关注具体的树状表示或者变量绑定的
等等细节. 现在看来, 对这种细节的过度关注与本科计算机科学
教育中对所谓 “语法解析 (parsing)”, 或者本科逻辑学
教育中对括号的匹配计数过度强调的不良风气是一脉相承的.
~\cite[(4.2\textasteriskcentered3)]{sterling:2021:thesis}
\end{quotation}

这一节的最后, 我们举一个例子： 群的语法. 它的主观语法比较
好理解. 首先我们有一些作为变量的符号 \(x,y,z,\dots\).
每个变量都是一个表达式. 如果 \(M, N\) 是表达式, 那么
\((M \cdot N)\) 和 \(M^{-1}\) 也是表达式. 同时
\(1\) 也是表达式. 这样, 表达式就例如
\((1^{-1} \cdot ((x \cdot y^{-1})^{-1} \cdot x))\) 等等.

对于这套简单的理论, 主观语法还是比较好处理的. 我们可以
归纳定义一个表达式的变量集 \(\mathrm{Var}(M)\). 上面
那个表达式的变量集就是 \(\{x, y\}\). 我们可以证明每个
表达式都只有唯一的一种方式从上面的规则中产生.

然后我们还需要描述群元素间的相等. 这在一般的类型论中称为%
\textbf{判值相等}(judgemental equality). 是理论中内生的相等
性. 与它相关的辨析也会在第\ref{martinlof}章中讲述.
我们定义表达式之间的一个等价关系, 这次使用逻辑学家更熟悉
的语言：
\[\frac{}{M = M}\quad
\frac{M = N}{N = M}\quad
\frac{M = N \quad N = P}{M = P}\]
这规定了 \(=\) 是个等价关系.
\[\frac{M = N}{M^{-1} = N^{-1}}\quad
\frac{M_1 = M_2\quad N_1 = N_2}
{(M_1 \cdot N_1) = (M_2 \cdot N_2)}\]
这规定了判值相等是\textbf{合同}(congruent)关系,
换言之, 把一个表达式 \(M\) 中的一部分 \(N\) 替换成
与之相等的另一个表达式 \(N'\), 得到的新表达式 \(M'\)
也等于原来的表达式 \(M\).
\[\frac{}{(1 \cdot M) = M}\quad
\frac{}{(M \cdot 1) = M}\]
\[\frac{}{((M \cdot N) \cdot P)
= (M \cdot (N \cdot P))} \quad
\frac{}{(M \cdot M^{-1}) = 1}\quad
\frac{}{(M^{-1} \cdot M) = 1}\]
注意这些规则都是没有前提, 因此是恒成立的. 这就规定了群
的主观语法. 用代数的眼光看, 这刚好是在构造由变量符号
生成的自由群. 这个视角是非常深刻的, 后面还会多次碰见.

那么客观语法如何呢? 这需要一定的范畴论工具. 我们后面会
详细介绍范畴论的知识. 这里只预先为读者提供一个大略的图像.
我们考虑一列群 \(F_n (n \in \mathbb N)\), 即有
\(n\) 个生成元的自由群. 它们之间的群同态构成一个范畴.
我们取这个范畴的对偶 \(\mathcal T\). 这个范畴代表了
上面的主观语法的客观化, 也称为群论的\textbf{语法范畴}.
我们会在下一节更仔细地讲述这个范畴的特性, 以及它如何与
主观语法相对应. 但是现在可以为已经掌握了一定范畴论
知识的读者罗列几点：\berry{3}
\begin{itemize}
\item 从 \(\mathcal T\) 到集合
范畴 \(\textsf{Set}\) 的保积函子与群一一对应.
\item 从 \(\mathcal T\) 到拓扑空间
范畴 \(\textsf{Top}\) 的保积函子与拓扑群一一对应.
\item 从 \(\mathcal T\) 到光滑流形
范畴 \(\textsf{Man}\) 的保积函子与Lie群一一对应.
\end{itemize}
这里保积函子指的是保持 Descartes 乘积的函子.

\section{类型论的语义}\label{intro:semantics}\berry{1}
% 朴素语义
语义是什么? 顾名思义, 就是指某种解释语言的方式.
我们还是以群的语言为例子. 群的语言中有 \(M\times N\)
与 \(M^{-1}\) 的操作, 那么我们朴素的语义中就可以解释为
一个集合 \(G\) 以及其上的两个函数 \(m : G\times G\to G,
i : G \to G\). 而表达式 \(1\) 就解释为 \(G\) 中选定的
某个元素 \(e\). (其实这可以认为是 “零元函数”, 因为
\(G^n \to G\) 就是 \(n\)元函数, 取 \(n = 0\) 得到
\(G^0 \to G\), 即从单点集出发的函数.) 这样, 任何表达式
就都能通过这些函数解释成具体的运算结果.
我们进一步要求选定的函数需要满足语法中规定的所有等式.
这样得到的语义我们已经很熟悉了： 一个群恰好是一种语义.
同时这也告诉我们, 同一个语言也可以有不同的语义, 甚至不一定有
典范的语义.

当然, 这只是把语言解释成了集合和函数. 我们没有理由把自己限制
到这些事物上. 譬如说我们把 “集合” 改为 “光滑流形”,
“函数” 改为 “光滑映射”. 读者可以发现这就是 Lie 群的定义.
这就促使我们思考, 怎样的数学结构就足够支撑语义的定义呢?
我们需要一个抽象的数学结构, 包含一些对象和它们
之间的映射. 这就自然的产生了范畴的概念.
\begin{definition}
一个\textbf{范畴} \(\mathcal C\) 包含
\begin{itemize}
\item 一个集合 \(\mathrm{Obj}(\mathcal C)\), 其中
的元素称为范畴\(\mathcal C\)的\textbf{对象}.\footnote{有时候我们
希望考虑如所有集合构成的范畴, 此时由于所有集合的集合不存在, 我们
需要将这个定义放宽. 这里不考虑这些问题, 但是在严格处理
的时候这些问题是非常重要的.}
\item 对于每对对象 \(A,B\), 一个集合 \(\hom_{\mathcal C}(A,B)\),
称为从 \(A\) 到 \(B\) 的\textbf{态射}或者\textbf{箭头}.
对于每个对象 \(A\), 都有一个态射
\(\cons{id}_A \in \hom_{\mathcal C}(A,A)\), 称作\textbf{恒同态射}. 对于两个态射
\[A \xrightarrow f B \xrightarrow g C\]
有其\textbf{复合态射} \(g\circ f \in \hom_{\mathcal C}(A, C)\).
\end{itemize}
它们满足一些等式. 恒同态射与其他箭头的复合满足
\(f \circ \cons{id} = f = \cons{id} \circ f.\)
并且三个顺次相连的态射复合满足结合律
\(f\circ (g\circ h) = (f\circ g)\circ h.\)
\end{definition}

那么集合与函数就构成一个范畴\(\cons{Set}\). 读者可以验证
函数的复合满足所需要的等式. 群与群同态也构成一个范畴 \(\cons{Grp}\),
等等. 进一步, 范畴之间保持其结构的映射就称为函子.
\begin{definition}
一个\textbf{函子} \(F : \mathcal C \to \mathcal D\) 包含
其对象的映射 \(\mathrm{Obj}(\mathcal C)
\to \mathrm{Obj}(\mathcal D)\) 与每对对象之间的
态射的映射 \(\hom_{\mathcal C}(A,B) \to \hom_{\mathcal D}(F(A), F(B))\).
它满足 \(F(\cons{id}_A) = \cons{id}_{F(A)}\) 与
\(F(f \circ g) = F(f)\circ F(g)\).
\end{definition}
再进一步, 函子之间保持其结构的映射称为自然变换.
\begin{definition}
对于两个函子 \(F,G : \mathcal C \to\mathcal D\),
一个\textbf{自然变换} \(\eta : F \to G\) 为一族
态射 \(\eta_X : F(X) \to G(X)\), 满足对于任何
\(f : X \to Y\), 下面的正方形图表交换 (即两条路径复合得到的是相等的态射).
\[\begin{tikzcd}
{F(X)} & {F(Y)} \\
{G(X)} & {G(Y)}
\arrow["{\eta_X}"', from=1-1, to=2-1]
\arrow["{\eta_Y}", from=1-2, to=2-2]
\arrow["{F(f)}", from=1-1, to=1-2]
\arrow["{G(f)}"', from=2-1, to=2-2]
\end{tikzcd}\]
\end{definition}
范畴论是非常丰富而深刻的学科.
读者可以阅读\cite{smith:2018:category}或\cite{maclane:1971:category}进一步学习.

我们有一个范畴还不够, 我们需要有对象的乘积来表达二元函数
\(G \times G \to G\). 在范畴中可以直接定义对象之间的
乘积.
\begin{definition}
给定一个范畴中的两个对象 \(A,B\), 如果有另一个对象 \(C\)
以及两个态射 \(\pi_1 : C \to A\), \(\pi_2:C \to B\),
满足对于任何一对态射 \(f : X \to A\), \(g : X \to B\),
都存在一个态射 \(u : X \to C\) 使得 \(f = \pi_1 \circ u\),
\(g = \pi_2 \circ u\), 就称 \(C\) 为 \(A,B\) 的\textbf{Descartes乘积},
记作 \(A \times B\).
\[\begin{tikzcd}
X \\
& C && B \\
\\
& A
\arrow["f"{description}, curve={height=6pt}, from=1-1, to=4-2]
\arrow["{\pi_1}"{description}, from=2-2, to=4-2]
\arrow["{\pi_2}"{description}, from=2-2, to=2-4]
\arrow["g"{description}, curve={height=-6pt}, from=1-1, to=2-4]
\arrow[dashed, from=1-1, to=2-2]
\end{tikzcd}\]
\end{definition}
读者可以验证集合的乘积、群的直积、向量空间的直积等等都满足条件.
因此这个定义恰当地刻画了我们称为积的许多不同定义. 范畴乘积
在同构意义下是唯一的.

同时, 我们还
需要表达“零元函数”的概念.
\begin{definition}
如果一个范畴中有一个对象 \(1\) 满足任何对象 \(X\) 到
\(1\) 都有唯一的态射, 那么这个对象称作\textbf{终对象}.
对偶地, 如果有一个对象 \(0\) 满足它到任何对象都有唯一的态射,
那么这个对象称作\textbf{始对象}.
\end{definition}
终对象可以看成是“零元乘积”.
在集合范畴中, 这就是单点集的定义. 我们有 \(1 \times X\)
与 \(X\) 同构等性质.
有了这些工具之后, 我们就可以在任何含有乘积和终对象的范畴
中定义群的语义了. 我们把群的语义定义为一个对象 \(G\),
态射\(i : G \to G\), \(m : G \times G \to G\),
\(e : 1 \to G\). 它们需要满足群的等式. 如考虑
\(\cons{id}, i : G \to G\) 这两个态射, 由范畴乘积的定义,
存在态射 \(\langle\cons{id}, i\rangle : G \to G \times G\).
这个态射可以与 \(m\) 复合. 另一方面由终对象的定义,
\(G \to 1\) 有唯一的态射, 它可以与 \(e\) 复合.
我们要求这两个复合映射 \(G \to G\) 相等.
这在集合范畴里说的就是 \(x \cdot x^{-1} = e\).
其他的等式也可以类似地重新表述.

为什么要花费这么大功夫, 把原来的等式表达得这么复杂呢?
这是因为我们重新表述了这个等式后, 它就可以立刻解放而
用到其他范畴中去.\footnote{事实上我们在
第~\ref{category:inner}~节中会介绍怎么既能得到好处,
又不使等式的表述过于复杂.} 譬如我们现在可以考虑
光滑流形与可微映射构成的范畴, 那么就立刻得到Lie群的定义.
如果在代数簇的范畴中, 就得到代数群的定义.

在1963年, Lawvere~\cite{Lawvere:1963:functorial}提出了
一种更优雅的表述方式. 如果我们希望考虑一个群 \(G\) 中的
两个元素 \(x,y\) 使得 \(x^2y^2 = e\), 那么我们可以将其
表述为从 \(\langle x,y \mid x^2y^2 \rangle\) 到 \(G\)
的群同态. 这是由 \(x,y\) 两个元素在满足我们需要的等式的
前提下自由生成的群. 如果读者接触过逻辑学,
那么可以类比 Lindenbaum--Tarski 代数, 它也蕴含着类似的思想.
类似地, 我们现在希望考虑某个范畴中的一个对象
以及态射 \(i,m,e\), 满足一些等式. 因此我们应该
寻找某个范畴 \(\mathcal T\), 它由 \(i,m,e\) 三个态射
在满足我们需要的等式前提下“自由生成”.

我们考虑由一个对象 \(\star\)
以及它自身的有限次乘积 \(\star^n (n \in \mathbb N)\) 构成的范畴.
我们考虑这样构成的范畴 \(\mathcal T\) 到其他范畴的
函子. 如果这个函子保持乘积结构, 那么它就由 \(F(\star)\)
的值唯一确定. 正如 \(\mathbb Z\) 到环 \(R\) 的环同态 \(f\)
由 \(f(1)\) 的值唯一确定. 如果我们进一步在范畴 \(\mathcal C\)
中自由加入一个态射 \(m:\star^2 \to \star\), 同时不破坏乘积结构,
那么从这个范畴出发的(保乘积结构的)函子就会由 \(F(\star)\)
与 \(F(m) : F(\star) \times F(\star) \to F(\star)\)
唯一决定. 如果 \(m\) 在范畴 \(\mathcal T\) 中满足一些
等式, 那么 \(F(m)\) 就会自然的满足这些等式.

那么我们就只需要解决两个问题： 如何具体构造这个范畴
\(\mathcal T\), 以及定义“保持乘积的函子”. 其中后者比较
简单, 大致来说我们只需要 \(F(A \times B)\) 与 \(F(A) \times F(B)\) 同构即可.
\begin{definition}
给定两个范畴 \(\mathcal C,\mathcal D\), 如果这两个
范畴中任意两个对象都有乘积, 那么考虑任何一个函子 \(F : \mathcal C \to \mathcal D\)
都有态射 \(F(A \times B) \to F(A) \times F(B)\).
如果这些态射对于任何 \(A,B \in \mathrm{Obj}(\mathcal C)\)
都是同构, 那么就称 \(F\) \textbf{保持二元乘积结构}.
如果进一步 \(F(1)\) 也是终对象, 那么就称 \(F\)
\textbf{保持有限乘积结构}, 简称为\textbf{保积函子}.
\end{definition}

接下来我们定义 \(\mathcal T\). 这只需要定义 \(\star^m\) 到
\(\star\) 的态射. 根据上面的讨论,
我们考虑所有使用 \(m\) 个变量
\(x_1,\dots,x_m\), 用乘法、逆元、单位元运算得到的
任意表达式. 如果有两个表达式 \(M,N\) 根据群满足的
等式 (结合律等等) 可以证明相等, 就记作 \(M \sim N\).
那么 \(\sim\) 是一个等价关系, 我们将表达式的集合商去这个
等价关系, 作为 \(\hom(\star^m, \star)\) 的定义.
而一般的 \(\hom(\star^m, \star^n)\) 可以定义为
\(n\) 个这样的表达式构成的有序对.

读者可能已经注意到了, 这样定义出来的正是 \ref{intro:syntax}~节中
介绍过的群的语法! 这样看来, 群的语义可以看作是从群的语法
构成的范畴出发的保积函子. 这就是\textbf{Lawvere函子语义}.
对于更复杂的理论, 我们也需要更加复杂的范畴结构, 因此考虑的
函子也相应地需要保持这些结构.

在 \ref{intro:syntax}~节中, 我们还提到了另一种构造语法范畴的方式.
考虑 \(n\) 个生成元的自由群, 它们与其间的群同态构成一个范畴.
我们将所有的箭头\emph{反向}, 就构成了语法范畴. 读者可以
验证这样得到的是完全相同的范畴, 不过这种表述更加简练.

既然任何一个从群语法范畴出发的保积函子都可以看作是
语义, 那么恒同函子 \(\mathcal T \to \mathcal T\)
自然也是一套语义, 也就是说语法本身构成平凡的语义.
更进一步, 考虑所有的语义构成的范畴.\footnote{这个范畴
中两个语义 \(F : \mathcal T \to \mathcal S_1,
G : \mathcal T \to \mathcal S_2\)之间的态射是一个
保积函子 \(H : \mathcal S_1 \to \mathcal S_2\),
满足 \(H \circ F = G\).}
在这个范畴中, 语法构成的平凡语义是始对象.

使用范畴表述的语法与语义, 在处理非常复杂的类型论 (如立方类型论) 时
是降低复杂程度, 让证明简洁清晰的有力武器. 不过我们
当然还需要证明这一套理论与传统的语法是等价的. 这类证明
一般表现为两个定理, 分别称作\textbf{完备性}与\textbf{可靠性}.
我们在\ref{beginning:henkin}节会再次提到.

%realizability \& forcing
%TODO I think we don't need to mention these?

\section{类型论的历史}\label{intro:unity}
在类型论研究的历史中, 语法和语义的研究是对立统一的关系.
起初, 人们写下语法规则, 然后通过分析这些规则试图
建立类型论的性质. 而选择这些规则的原因, 是人们脑中
期望这些规则所拥有的语义. 在分析的过程中, 人们会发现
为了证明类型论的一些性质, 需要考虑比一开始期望的语义更广义
的其他语义. 而这些新的语义的发现又促使人们写下新的规则,
构造新的类型论. 这是一个事物走向自身的否定, 进而走向否定
的否定的过程.

事实上, 类型论的发展像很多学科一样, 从某个主干开始
不断产生不同的分支. 而每个时期中数学家对不同分支投入的精力
不同. 我们会大致以每个分支产生的时间顺序讲述, 但是并非严格如此.
譬如较老的分支在后来的应用上产生了成果, 我仍然会在讲述这个分支
的章节一并介绍.

如上文所述, 本文将会以对语法和语义的研究之间的矛盾运动
为主线. 类型论有非常广泛的分支和应用, 本文不可能面面俱到.
如在计算机科学中用于对程序的正确性进行检查的类型论, 由于和
数学中提到的类型论关系较远, 文章中就不做过多介绍. 我们从Russell
的类型论出发, 以当代研究前沿的立方类型论为终点.
