\chapter{Martin-L\"of类型论}\label{martinlof}

Martin-L\"of 在 70 年代前后提出了多个类似的类型论.
其中最本质的特征在于接下来介绍的相等类型. 因此我们会把
具有类似特征的其他类型论也归到此类介绍.

我们首先回顾一下之前遇到的类型. 我们有依值函数的
\(\Pi\)-类型, 还有 \(\Sigma\)-类型表示后者的类型依赖于
前者的值有序对的类型. 一般的函数类型 \(\to\) 与乘积类型
\(\times\) 可以分别表示为它们的特殊情况.
在纯类型系统中, 我们介绍了类型的
类型 (如 \(\cons{type}, \cons{kind}\) 等) 对类型系统
的影响. 接下来我们会称这些对象为\textbf{宇宙}.

\section{归纳类型}

我们可以继续引入类型, 例如自然数. 首先有两种构造自然数
的方式：一种是 \(\cons{zero} : \mathbb N\); 一种
是给定一个自然数 \(n : \mathbb N\), 取它的后继
\(\cons{succ}(n) : \mathbb N\). 我们称
\(\cons{zero}\) 与 \(\cons{succ}\) 为\textbf{构造子}.
除了能够构造自然数之外, 我们还需要能够使用
自然数.\footnote{构造子就是\emph{输出}是自然数的函数
(\(\cons{zero}\)是有零个参数的函数), 而我们需要\emph{输入}是自然数的函数.
在数学中我们经常遇到的\emph{泛性质}就是类似的思想.}
Curry--Howard对应在这里又发挥了神奇的作用：用于证明命题的
归纳法与用于定义函数的递归定义法, 实际上是同一件事情!
考虑\textbf{消去子}
\[\cons{elim} :
\prod_{P : \mathbb N \to \cons{type}}
P(\cons{zero}) \to
\left[\prod_{m : \mathbb N} P(m) \to P(\cons{succ}(m))\right]
\to \prod_{n : \mathbb N} P(n).\]
回忆之前提到的使用嵌套的函数类型表示多个参数的函数的技巧.
同时这里 \(\Pi\)-类型的优先级最低. 如果从逻辑的视角阅读
这个类型, 我们得到的就是
\begin{quotation}
对于所有含有变量 \(n : \mathbb N\) 的命题 \(P(n)\),
如果 \(P(\cons{zero})\) 成立, 并且对于每个
\(m : \mathbb N\), \(P(m)\) 可以推出 \(P(\cons{succ}(m))\),
那么命题就对所有的 \(n\) 成立.
\end{quotation}
这无疑就是归纳法. 而另一方面, 如果我们代入 \(P(n) = \mathbb N\),
那么这个类型就变成了
\[\underbrace{\mathbb N}_{f(0)} \to
[\underbrace{\overbrace{\mathbb N}^{m} \to \overbrace{\mathbb N}^{f(m)} \to \mathbb N}
_{\text{利用 \(m\) 与 \(f(m)\) 表达 \(f(m+1)\)}}] \to
\underbrace{\mathbb N \to \mathbb N}_{\text{得到 \(f\)}}.\]
这就是递归定义. 作为例子, 如果我们令
\(f(0) = 0\), \(f(m+1) = f(m)+2\), 那么
\(f\) 就是将输入乘以\(2\)的函数. 具体写出来就是
\[\cons{elim}\, P\,0\,\lambda m u. \cons{succ}(\cons{succ}(u))\]
这里用了类似之前的记号, \(fmn\) 表示函数 \(f\) 接受两个参数 \(m\) 与 \(n\).
读者可以自行和类型比对. 在\cite{friedman:2018:typer}中
作者用谈话的形式, 趣味十足地讲解了类似的各种构造,
读者可以参考. 对于一般的 \(P\), 这就是依赖类型下的递归.
譬如如果定义了向量空间的概念, 我们可以用消去子构造一个函数,
输入 \(n\), 输出 \(n\)维向量空间中的零向量. 这样就要求
\(P(n)\) 是 “\(n\)维向量空间” 这个类型, 因此依赖于 \(n\).

为了递归能够成立, 我们还要引入相关的等式. 我们在之前也
已经为函数类型引入了等式. 这实际上是表达式上的等价关系.
如果我们定义了一个函数 \(f = \cons{elim}\,P\,z\,s\),
那么我们希望 \(f(\cons{zero}) = z\), 并且
\(f(\cons{succ}(n)) = s\,n\,f(n)\). 我们用
阿拉伯数字简写自然数, 那么就有
\[f(3) = s\,2\,f(2) = s\,2\,(s\,1\,f(1)) = s\,2\,(s\,1\,(s\,0\,z)).\]
这些类型可以推广到一般的\textbf{归纳类型}, 以及
更强大的一些变体, 如 Martin-L\"of 引入了 W-类型的概念.
我们不详细介绍.

\section{相等类型}
数学中最常见的命题就是两个对象的相等. 因此由 Curry--Howard
对应, 我们应该有一个类型反映这一点. 对于两个同类型的元素
\(x,y : A\), 我们有\textbf{相等类型} \(x =_A y\).\footnote{这
在文献中有许多不同的记号. 有些文献使用 \(\equiv\),
还有一些文献直接使用 \(\cons{Id}_A(x,y)\).}
如果没有歧义, 可以简写成 \(x = y\).

注意这和我们之前使用的等号含义有所区别. 之前使用的等号,
其描述的相等性都是“不言自明”的. 如将一个复杂的表达式用
一个字母缩写, 此时我们认为这个缩写并不存在于类型论中,
只是为了人们实际书写方便而引入的. 还有如 \((\lambda x.x)y = y\)
的等式; 上面介绍了自然数可以用递归定义加法, 则
\(3 + 5 = 8\) 也是类似的等式. 这些等式在很多情况下
都是有机械的化简或者判定相等的方法的. 然而, 我们引入的
相等类型可以描述如 \(m + n =_{\mathbb N} n + m\) 或者 \(\zeta(2) =_{\mathbb R} \frac{\pi^2}{6}\)
这样的需要证明的定理. 这些显然没有机械的判定方法, 否则
数学家都要失业了!
我们称前者为\textbf{判值相等} (judgemental equality),
而后者(即相等类型)为\textbf{命题相等} (propositional equality).
自然, 判值相等的东西也命题相等.

命题相等还有一个特点, 就是我们可以用它们来构造更复杂的命题,
如 \(\neg (a^3 + b^3 =_{\mathbb N} c^3)\) 等等.
判值相等是表达式上的等价关系, 并不是一个类型, 所以不能
参与构造更复杂的命题.

为什么我们需要这样辨析相等的概念呢? 其实前一章中已经暗示
了这一点. 假如我们有一个 \(\mathbb R^{1+1}\) 类型
中的元素, 那么我需要能将它用于 \(\mathbb R^2\) 中.
这就需要类型论中有一个可以机械地判断的相等概念, 否则就无法
机械地判断某个表达式类型是否正确, 进而在Curry--Howard对应下
就意味着无法判断某个证明是否真的证明了命题. 一个类型论
不一定需要有命题相等, 但是一定有判值相等的概念. 当然这个概念
可以是平凡的, 比如只有字面相等的表达式才判值相等; 这就
产生了\textbf{弱类型论}(weak type theory).\footnote{Martin-L\"of
类型论又称作\textbf{内涵类型论}(intensional
type theory).} 在另一个极端, 我们也可以设定一条规则, 让命题相等
的概念和判值相等的概念重合:
\[\frac{M =_A N}{M = N}.\]
这就产生了\textbf{外延类型论}(extensional type theory).
这样的代价就是判值相等不再可以机械地判定, 因此在其中
写下一个命题的证明, 也没有明确的办法判断这是否是正确的
证明. 这三种类型论的联系可以参考~\cite{winterhalter:2018:ettwtt}.

不过, 我们还得先说明相等类型本身的规则是什么. 首先是
构造子
\[\cons{refl}_a : a =_A a.\]
这对应\emph{同一律}： 每个元素都等于其自身.
我们有对应的消去子
\[\cons{J} :
\prod_{P : \prod_{a,b:A} a = b \to \cons{type}}
\left[\prod_{c : A} P\,a\,a\,\cons{refl}_a\right] \to \prod_{a,b:A}\prod_{p : a=b} P\,a\,b\,p\]
这说的是“如果 \(P\) 对所有的 \(\cons{refl}\) 都成立,
那么它就对所有的 \(p : a=_A b\) 成立”.
在实用的类型论中, 通常会允许省略前面两个参数. 因此可以直接写做
\(P\,\cons{refl}_a\), 可以通过上下文推导出两个省略
的参数都是 \(a\). 同时我们为了方便也会将
\(\cons{refl}_a\) 省略为 \(\cons{refl}\).
类似地, 消去子和构造子的组合有一个等式, 这里不再给出.
读者可以参考~\cite{ufp:2013:hottbook}. 用字母J是因为
Martin-L\"of在论文~\cite{martinlof:1984:J}中的相等
类型使用了 I, 而下一个字母就是 J.

神奇的是, 用 J 原理就足够证明等式的各种性质, 比如对称性
\[\prod_{a,b:A} a = b \to b = a\]
与传递性
\[\prod_{a,b,c:A} a=b \to b=c \to a=c.\]
给定任何一个表达式 \(P(x)\), 如果有 \(a=b\),
那么 \(P(a) = P(b)\). 如果类型 \(A = B\), 那么
其间有一个双射. 这些性质的证明, 读者可以参考~\cite[\S1.12]{ufp:2013:hottbook}.

不过仍然有一些问题无法只靠J原理解决. 其中最简单的例子是
函数的\textbf{外延性}, 即如果两个函数逐点相等, 那么它们
相等.
\[\cons{funext} : \prod_{f,g : A \to B}
\left[\prod_{x : A} f(x) = g(x)\right] \to f = g.\]
这在Martin-L\"of类型论中是无法证明或者证伪的.
在\cite{boulier:2017:syntacticmodel}中有非常简单易懂的证明.
这可以看作是Martin-L\"of类型论的一个缺点, 也可以理解为一种优点.
比如将函数看作算法, 那么尽管两个函数逐点相等, 它们的算法不同,
计算需要的时间也不同. 因此函数外延性在研究算法复杂度时就的确是不成立的.
我们可以将这些命题作为额外的公理加入到理论中.

Martin-L\"of类型论中还有一个重要的缺憾是没有\textbf{商类型}.
在数学中, 商去一个等价关系是极其常见的操作, 但是在
Martin-L\"of类型论中很难加入对应的类型, 同时保证
类型论仍然具有好的性质. 注意我们可以直接将商类型作为
公理加入, 但是其他的类型均不需要公理, 这在审美上有一点
缺陷. 同时在证明类型论的性质时, 这种任意加入的公理一般
很难处理. 另外, 对于其他的类型, 我们都有对应的判值相等等式,
而公理只能影响命题相等, 因此判值相等的性质就被破坏了.
不过, 使用在 \ref{ch:bishop}~节中提到的广集的概念,
可以一定程度上规避这个问题. 这样做的缺点是每个广集上都
自带一个不同的等价关系作为“相等”, 因此需要时刻处理这些
额外的信息, 在严格书写证明的时候非常繁琐.

\section{宇宙}

在Martin-L\"of类型论最早的版本(于1971年提出, 一般
被称作MLTT\textsubscript{71})中, 只有一个宇宙
\(\cons{type}\), 满足 \(\cons{type} : \cons{type}\).
这个系统中存在Russell悖论. 因此后继的几个版本中,
Martin-L\"of对此做出了一些修改. MLTT\textsubscript{73}中,
引入了一套\textbf{宇宙层级}, 即引入可数个宇宙
\(\cons{type}_i : \cons{type}_{i+1}\).
其中 \(i\) 不是类型论内部的自然数, 而是我们为了书写
方便引入的, 实际上有可数个不同的符号.

宇宙的规则与之前提到的构造演算有一个重要的不同.
构造演算有两层宇宙 \(\cons{type} : \cons{kind}\),
我们写成 \(\cons{type}_i (i = 1,2)\). 那么如果
\(A : \cons{type}_i, B : \cons{type}_j\), 函数类型
就有 \(A \to B : \cons{type}_j\). 注意函数类型
一定在后者的宇宙之中, 尽管有可能 \(i > j\). 这意味着
这里的函数类型表现得与集合论中的函数集合相差甚远, 因为
考虑函数类型 \(\cons{type}_1 \to A\), 其中 \(A : \cons{type}_1\)
是任意一个类型. 那么这个函数类型的定义域中也包含 \(\cons{type}_1 \to A\),
但是如ZFC集合论中函数集合的定义域无论如何也不能包含这个函数集合
自身!

在Martin-L\"of类型论中, 如果
\(A : \cons{type}_i, B : \cons{type}_j\), 函数类型
就有 \(A \to B : \cons{type}_{\max\{i,j\}}\).
这使得Martin-L\"of类型论成为一种\textbf{直谓类型论}
(predicative type theory).\footnote{直谓一词有
多个相关但不等同的含义, 这里只是一种含义.} 这样, 在一般
数学中的一些非直谓的定义就会出现一些复杂的变化. 譬如在
拓扑的定义中, 我们需要考虑任何一族开集的并. 假设开集的
类型是 \(\Omega : \cons{type}_i\), 那么如何描述一族
开集 \(U_\alpha\) 呢? 我们需要一个指标 \(\alpha : A\),
因此 \(U\) 可以看作是 \(A \to \Omega\) 的函数.
这便出现了一个问题： 类型 \(A : \cons{type}_j\) 中,
\(j\) 的取值应该是什么? 并不是任意选择都合理, 因为
我们可能无法把一个集合 \(S\) 的内部定义成所有开集 \(U \subseteq S\)
的并, 它的宇宙层级不正确.

这些问题在经典数学中其实也有体现, 为了避免Russell悖论,
一部分数学家(包括Russell本人)提出我们应当避免
非直谓的操作. 在受到这些限制的情况下发展的数学, 统称
为\textbf{直谓数学}. 构造主义又给直谓数学增添了新的
内容： 有些公理与排中律可以共同推出一些非直谓的结论, 因此
经典直谓数学中拒绝这些公理. 在构造主义直谓数学中却可以
允许这些公理存在. 读者可以阅读(...)进一步了解直谓数学.

构造演算中允许高度的非直谓性. 这导致轻微的拓展就容易
出现Russell类的悖论. 作为妥协, 在很多变种中,
只允许最底层的宇宙有非直谓性. 换言之, 如果 \(A : \cons{type}_i\),
\(B : \cons{type}_j\), 那么
\(A \to B : \cons{type}_{f(i,j)}\), 其中
\[f(i,j) = \begin{cases}
1 & (j = 1)\\
\max\{i,j\} & (j > 1)
\end{cases}\]
最底层的宇宙通常被称为命题宇宙, 写作 \(\cons{prop}\).
构造演算原本不存在集合论的对应, 但是如此修改之后, 可以
将 \(\cons{prop}\) 中的类型对应为集合论中的命题.
这样修改之后, 构造演算就能加入类似Martin-L\"of类型论
中的归纳类型与相等类型等等. 不过底层的非直谓性仍然会给
类型论设计带来一些困难, 因此为了避免悖论需要注意很多技术细节.
这种类型论称为\textbf{归纳构造演算}(Calculus of Inductive
Constructions, 缩写为 CIC).

\section{自洽性}

由于对宇宙的直谓性安排, 很容易证明Martin-L\"of类型论
有\textbf{自洽性}, 即不存在元素 \(u : \mathbf 0\).
这里 \(u\) 不能含有自由变量. 根据 Curry--Howard 对应,
这意味着理论没有矛盾.

我们将每个类型解释为集合. 如 \(\mathbf 0\) 是空集,
\(\mathbb{N}\) 是自然数集, 等等. \(\cons{type}_1\)
则是集合的集合, 并且它在 \(\Sigma\)-类型,
\(\Pi\)-类型, 相等类型等等操作下封闭. 这在集合论中
对应一个熟知的构造. 接下来, 我们设 \(\cons{type}_2\)
解释为包含 \(\cons{type}_1\), 并且在同样的操作下
封闭的集合, 以此类推. 这样我们为每个类型都赋予了一个集合.
并且对于每个类型论的元素 \(x : A\), 我们都能在 \(A\)
对应的集合中找到一个对应的元素. 而空集没有元素, 因此类型
\(\mathbf 0\) 中没有元素.

然而, 依值类型论中只有自洽性是不够的. 因为有自洽性不代表
存在一个机械的方法判断某个证明是否正确. 我们需要更强的典范性.
Martin-L\"of类型论的典范性证明, 要么初等而极其繁琐, 要么
需要一定的范畴论知识. 读者可以参考~\cite[\S5.6]{sterling:2021:thesis}.

\section{应用}

Martin-L\"of类型论及其变体有非常广泛的应用, 这里拾取一些介绍.

\subsection{Coq}

\subsection{Lean}

Lean (实际上是CoC + Inductive等)
液态张量.\cite{scholze:2020:liquid}

\subsection{Agda}

\subsection{其他}

\textbf{逻辑框架}(logical framework) 虽然规则上
大体相似, 但是与上文描述的 Martin-L\"of 类型论
的使用方式风格非常不同. 一个具体的软件实现是Twelf,
主要用于程序验证等.

NuPRL 与 Andromeda 是基于外延类型论的计算机辅助证明软件.
尽管上文中我们说过外延集合论中一个证明是否正确难以机械判定,
但是这些软件中允许用户手动插入额外的说明, 用于帮助软件进行判断.

