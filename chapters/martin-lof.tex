\chapter{Martin-L\"of类型论}\label{martinlof}

Martin-L\"of 在 70 年代前后提出了多个类似的类型论.
其中最本质的特征在于接下来介绍的相等类型. 因此我们会把
具有类似特征的其他类型论也归到此类介绍.

我们首先回顾一下之前遇到的类型. 我们有依值函数的
\(\Pi\)-类型, 还有 \(\Sigma\)-类型表示后者的类型依赖于
前者的值有序对的类型. 一般的函数类型 \(\to\) 与乘积类型
\(\times\) 可以分别表示为它们的特殊情况.
在纯类型系统中, 我们介绍了类型的
类型 (如 \(\cons{type}, \cons{kind}\) 等) 对类型系统
的影响. 接下来我们会称这些对象为\textbf{宇宙}.

\section{归纳类型}

我们可以继续引入类型, 例如自然数. 首先有两种构造自然数
的方式：一种是 \(\cons{zero} : \mathbb N\); 一种
是给定一个自然数 \(n : \mathbb N\), 取它的后继
\(\cons{succ}(n) : \mathbb N\). 我们称
\(\cons{zero}\) 与 \(\cons{succ}\) 为\textbf{构造子}.
除了能够构造自然数之外, 我们还需要能够使用
自然数.\footnote{构造子就是\emph{输出}是自然数的函数
(\(\cons{zero}\)是有零个参数的函数), 而我们需要\emph{输入}是自然数的函数.
在数学中我们经常遇到的\emph{泛性质}就是类似的思想.}
Curry--Howard对应在这里又发挥了神奇的作用：用于证明命题的
归纳法与用于定义函数的递归定义法, 实际上是同一件事情!
考虑\textbf{消去子}
\[\cons{elim} :
\prod_{P : \mathbb N \to \cons{type}}
P(\cons{zero}) \to
\left[\prod_{m : \mathbb N} P(m) \to P(\cons{succ}(m))\right]
\to \prod_{n : \mathbb N} P(n).\]
回忆之前提到的使用嵌套的函数类型表示多个参数的函数的技巧.
同时这里 \(\Pi\)-类型的优先级最低. 如果从逻辑的视角阅读
这个类型, 我们得到的就是
\begin{quotation}
对于所有含有变量 \(n : \mathbb N\) 的命题 \(P(n)\),
如果 \(P(\cons{zero})\) 成立, 并且对于每个
\(m : \mathbb N\), \(P(m)\) 可以推出 \(P(\cons{succ}(m))\),
那么命题就对所有的 \(n\) 成立.
\end{quotation}
这无疑就是归纳法. 而另一方面, 如果我们代入 \(P(n) = \mathbb N\),
那么这个类型就变成了
\[\underbrace{\mathbb N}_{f(0)} \to
[\underbrace{\overbrace{\mathbb N}^{m} \to \overbrace{\mathbb N}^{f(m)} \to \mathbb N}
_{\text{利用 \(m\) 与 \(f(m)\) 表达 \(f(m+1)\)}}] \to
\underbrace{\mathbb N \to \mathbb N}_{\text{得到 \(f\)}}.\]
这就是递归定义. 作为例子, 如果我们令
\(f(0) = 0\), \(f(m+1) = f(m)+2\), 那么
\(f\) 就是将输入乘以\(2\)的函数. 具体写出来就是
\[\cons{elim}\, P\,\cons{zero}\,\lambda m u. \cons{succ}(\cons{succ}(u))\]
这里用了类似之前的记号, \(fmn\) 表示函数 \(f\) 接受两个参数 \(m\) 与 \(n\).
读者可以自行和类型比对. 在\cite{friedman:2018:typer}中
作者用谈话的形式, 趣味十足地讲解了类似的各种构造,
读者可以参考. 对于一般的 \(P\), 这就是依值类型下的递归.
譬如如果定义了向量空间的概念, 我们可以用消去子构造一个函数,
输入 \(n\), 输出 \(n\)维向量空间中的零向量. 这样就要求
\(P(n)\) 是 “\(n\)维向量空间” 这个类型, 因此依赖于 \(n\).

为了递归能够成立, 我们还要引入相关的等式. 我们在之前也
已经为函数类型引入了等式. 这实际上是表达式上的等价关系.
如果我们定义了一个函数 \(f = \cons{elim}\,P\,z\,s\),
那么我们希望 \(f(\cons{zero}) = z\), 并且
\(f(\cons{succ}(n)) = s\,n\,f(n)\). 我们用
阿拉伯数字简写自然数, 那么就有
\[f(3) = s\,2\,f(2) = s\,2\,(s\,1\,f(1)) = s\,2\,(s\,1\,(s\,0\,z)).\]
这些类型可以推广到一般的\textbf{归纳类型}, 以及
更强大的一些变体, 如 Martin-L\"of 引入了 W-类型的概念.
我们不详细介绍.

\section{相等类型}\label{martinlof:identity}
数学中最常见的命题就是两个对象的相等. 因此由 Curry--Howard
对应, 我们应该有一个类型反映这一点. 对于两个同类型的元素
\(x,y : A\), 我们有\textbf{相等类型} \(x =_A y\).\footnote{这
在文献中有许多不同的记号. 有些文献使用 \(\equiv\),
还有一些文献直接使用 \(\cons{Id}_A(x,y)\).}
如果没有歧义, 可以简写成 \(x = y\).

注意这和我们之前使用的等号含义有所区别. 之前使用的等号,
其描述的相等性都是“不言自明”的. 如将一个复杂的表达式用
一个字母缩写, 此时我们认为这个缩写并不存在于类型论中,
只是为了人们实际书写方便而引入的. 还有如 \((\lambda x.x)y = y\)
的等式; 上面介绍了自然数可以用递归定义加法, 则
\(3 + 5 = 8\) 也是类似的等式. 这些等式在很多情况下
都是有机械的化简或者判定相等的方法的. 然而, 我们引入的
相等类型可以描述如 \(m + n =_{\mathbb N} n + m\) 或者 \(\zeta(2) =_{\mathbb R} \frac{\pi^2}{6}\)
这样的需要证明的定理. 这些显然没有机械的判定方法, 否则
数学家都要失业了!
我们称前者为\textbf{判值相等} (judgemental equality),
而后者(即相等类型)为\textbf{命题相等} (propositional equality).
自然, 判值相等的东西也命题相等.

命题相等还有一个特点, 就是我们可以用它们来构造更复杂的命题,
如 \(\neg (a^3 + b^3 =_{\mathbb N} c^3)\) 等等.
判值相等是表达式上的等价关系, 并不是一个类型, 所以不能
参与构造更复杂的命题.

为什么我们需要这样辨析相等的概念呢? 其实前一章中已经暗示
了这一点. 假如我们有一个 \(\mathbb R^{1+1}\) 类型
中的元素, 那么我需要能将它用于 \(\mathbb R^2\) 中.
这就需要类型论中有一个可以机械地判断的相等概念, 否则就无法
机械地判断某个表达式类型是否正确, 进而在Curry--Howard对应下
就意味着无法判断某个证明是否真的证明了命题. 一个类型论
不一定需要有命题相等, 但是一定有判值相等的概念. 当然这个概念
可以是平凡的, 比如只有字面相等的表达式才判值相等; 这就
产生了\textbf{弱类型论}(weak type theory).\footnote{Martin-L\"of
类型论又称作\textbf{内涵类型论}(intensional
type theory).} 在另一个极端, 我们也可以设定一条规则, 让命题相等
的概念和判值相等的概念重合:
\[\frac{M =_A N}{M = N}.\]
这就产生了\textbf{外延类型论}(extensional type theory).
这样的代价就是判值相等不再可以机械地判定, 因此在其中
写下一个命题的证明, 也没有明确的办法判断这是否是正确的
证明. 这三种类型论的联系可以参考~\cite{winterhalter:2018:ettwtt}.

不过, 我们还得先说明相等类型本身的规则是什么. 首先是
构造子
\[\cons{refl}_a : a =_A a.\]
这对应\emph{同一律}： 每个元素都等于其自身.
我们有对应的消去子
\[\cons{J} :
\prod_{P : \prod_{a,b:A} a = b \to \cons{type}}
\left[\prod_{c : A} P\,a\,a\,\cons{refl}_a\right] \to \prod_{a,b:A}\prod_{p : a=b} P\,a\,b\,p\]
这说的是“如果 \(P\) 对所有的 \(\cons{refl}\) 都成立,
那么它就对所有的 \(p : a=_A b\) 成立”.
在实用的类型论中, 通常会允许省略前面两个参数. 因此可以直接写做
\(P\,\cons{refl}_a\), 可以通过上下文推导出两个省略
的参数都是 \(a\). 同时我们为了方便也会将
\(\cons{refl}_a\) 省略为 \(\cons{refl}\).
类似地, 消去子和构造子的组合有一个等式, 这里不再给出.
读者可以参考~\cite{ufp:2013:hottbook}. 用字母J是因为
Martin-L\"of在论文~\cite{martinlof:1984:J}中的相等
类型使用了 I, 而下一个字母就是 J.

神奇的是, 用 J 原理就足够证明等式的各种性质, 比如对称性
\[\prod_{a,b:A} a = b \to b = a\]
与传递性
\[\prod_{a,b,c:A} a=b \to b=c \to a=c.\]
给定任何一个表达式 \(P(x)\), 如果有 \(a=b\),
那么 \(P(a) = P(b)\). 如果类型 \(A = B\), 那么
其间有一个双射. 这些性质的证明, 读者可以参考~\cite[\S1.12]{ufp:2013:hottbook}.

不过仍然有一些问题无法只靠J原理解决. 其中最简单的例子是
函数的\textbf{外延性}, 即如果两个函数逐点相等, 那么它们
相等.
\[\cons{funext} : \prod_{f,g : A \to B}
\left[\prod_{x : A} f(x) = g(x)\right] \to f = g.\]
这在Martin-L\"of类型论中是无法证明或者证伪的.
在\cite{boulier:2017:syntacticmodel}中有非常简单易懂的证明.
这可以看作是Martin-L\"of类型论的一个缺点, 也可以理解为一种优点.
比如将函数看作算法, 那么尽管两个函数逐点相等, 它们的算法不同,
计算需要的时间也不同. 因此函数外延性在研究算法复杂度时就的确是不成立的.
尽管如函数外延性之类的命题无法证明, 我们还是可以
将这些命题作为额外的公理加入到理论中.

Martin-L\"of类型论中还有一个重要的缺憾是没有\textbf{商类型}.
在数学中, 商去一个等价关系是极其常见的操作, 但是在
Martin-L\"of类型论中很难加入对应的类型, 同时保证
类型论仍然具有好的性质. 注意我们可以直接将商类型作为
公理加入, 但是其他的类型均不需要公理, 这在审美上有一点
缺陷. 同时在证明类型论的性质时, 这种任意加入的公理一般
很难处理. 另外, 对于其他的类型, 我们都有对应的判值相等等式,
而公理只能影响命题相等, 因此判值相等的性质就被破坏了.
不过, 使用在 \ref{ch:bishop}~节中提到的广集的概念,
可以一定程度上规避这个问题. 这样做的缺点是每个广集上都
自带一个不同的等价关系作为“相等”, 因此需要时刻处理这些
额外的信息, 在严格书写证明的时候非常繁琐.

\section{宇宙}

在Martin-L\"of类型论最早的版本(于1971年提出, 一般
被称作MLTT\textsubscript{71})中, 只有一个宇宙
\(\cons{type}\), 满足 \(\cons{type} : \cons{type}\).
这个系统中存在Russell悖论. 因此后继的几个版本中,
Martin-L\"of对此做出了一些修改. MLTT\textsubscript{73}中,
引入了一套\textbf{宇宙层级}, 即引入可数个宇宙
\(\cons{type}_i : \cons{type}_{i+1}\).
其中 \(i\) 不是类型论内部的自然数, 而是我们为了书写
方便引入的, 实际上有可数个不同的符号.

宇宙的规则与之前提到的构造演算有一个重要的不同.
构造演算有两层宇宙 \(\cons{type} : \cons{kind}\),
我们写成 \(\cons{type}_i (i = 1,2)\). 那么如果
\(A : \cons{type}_i, B : \cons{type}_j\), 函数类型
就有 \(A \to B : \cons{type}_j\). 注意函数类型
一定在后者的宇宙之中, 尽管有可能 \(i > j\). 这意味着
这里的函数类型表现得与集合论中的函数集合相差甚远, 因为
考虑函数类型 \(\cons{type}_1 \to A\), 其中 \(A : \cons{type}_1\)
是任意一个类型. 那么这个函数类型的定义域中也包含 \(\cons{type}_1 \to A\),
但是如ZFC集合论中函数集合的定义域无论如何也不能包含这个函数集合
自身!

在Martin-L\"of类型论中, 如果
\(A : \cons{type}_i, B : \cons{type}_j\), 函数类型
就有 \(A \to B : \cons{type}_{\max\{i,j\}}\).
这使得Martin-L\"of类型论成为一种\textbf{直谓类型论}
(predicative type theory).\footnote{直谓一词有
多个相关但不等同的含义, 这里只是一种含义.} 这样, 在一般
数学中的一些非直谓的定义就会出现一些复杂的变化. 譬如在
拓扑的定义中, 我们需要考虑任何一族开集的并. 假设开集的
类型是 \(\Omega : \cons{type}_i\), 那么如何描述一族
开集 \(U_\alpha\) 呢? 我们需要一个指标 \(\alpha : A\),
因此 \(U\) 可以看作是 \(A \to \Omega\) 的函数.
这便出现了一个问题： 类型 \(A : \cons{type}_j\) 中,
\(j\) 的取值应该是什么? 并不是任意选择都合理, 因为
我们可能无法把一个集合 \(S\) 的内部定义成所有开集 \(U \subseteq S\)
的并, 它的宇宙层级不正确.

这些问题在经典数学中其实也有体现, 为了避免Russell悖论,
一部分数学家(包括Russell本人)提出我们应当避免
非直谓的操作. 在受到这些限制的情况下发展的数学, 统称
为\textbf{直谓数学}. 构造主义又给直谓数学增添了新的
内容： 有些公理与排中律可以共同推出一些非直谓的结论, 因此
经典直谓数学中拒绝这些公理. 在构造主义直谓数学中却可以
允许这些公理存在. 读者可以
阅读\cite{feferman:2000:predicative}进一步
了解直谓数学.

构造演算中允许高度的非直谓性. 这导致轻微的拓展就容易
出现Russell类的悖论. 作为妥协, 在很多变种中,
只允许最底层的宇宙有非直谓性. 换言之, 如果 \(A : \cons{type}_i\),
\(B : \cons{type}_j\), 那么
\(A \to B : \cons{type}_{f(i,j)}\), 其中
\[f(i,j) = \begin{cases}
1 & (j = 1)\\
\max\{i,j\} & (j > 1)
\end{cases}\]
最底层的宇宙通常被称为命题宇宙, 写作 \(\cons{prop}\).
构造演算原本不存在集合论的对应, 但是如此修改之后, 可以
将 \(\cons{prop}\) 中的类型对应为集合论中的命题.
这样修改之后, 构造演算就能加入类似Martin-L\"of类型论
中的归纳类型与相等类型等等. 不过底层的非直谓性仍然会给
类型论设计带来一些困难, 因此为了避免悖论需要注意很多技术细节.
这种类型论称为\textbf{归纳构造演算}(Calculus of Inductive
Constructions, 缩写为 CIC).

\section{自洽性}

由于对宇宙的直谓性安排, 很容易证明Martin-L\"of类型论
有\textbf{自洽性}, 即不存在元素 \(u : \mathbf 0\).
这里 \(u\) 不能含有自由变量. 根据 Curry--Howard 对应,
这意味着理论没有矛盾.

我们将每个类型解释为集合. 如 \(\mathbf 0\) 是空集,
\(\mathbb{N}\) 是自然数集, 等等. \(\cons{type}_1\)
则是集合的集合, 并且它在 \(\Sigma\)-类型,
\(\Pi\)-类型, 相等类型等等操作下封闭. 这在集合论中
对应一个熟知的构造. 接下来, 我们设 \(\cons{type}_2\)
解释为包含 \(\cons{type}_1\), 并且在同样的操作下
封闭的集合, 以此类推. 这样我们为每个类型都赋予了一个集合.
并且对于每个类型论的元素 \(x : A\), 我们都能在 \(A\)
对应的集合中找到一个对应的元素. 而空集没有元素, 因此类型
\(\mathbf 0\) 中没有元素.

然而, 依值类型论中只有自洽性是不够的. 因为有自洽性不代表
存在一个机械的方法判断某个证明是否正确. 我们需要更强的典范性.
Martin-L\"of类型论的典范性证明, 要么初等而极其繁琐, 要么
需要一定的范畴论知识. 我们在之后会介绍一定的范畴论工具.
读者也可以参考~\cite[\S5.6]{sterling:2021:thesis}.

\section{应用}

Martin-L\"of类型论及其变体有非常广泛的应用, 这里拾取一些介绍.

\subsection{Coq}

Coq是一套交互式定理证明软件. 它基于构造归纳演算, 名字也来源于
构造演算的缩写 CoC 与其提出者 Coquand 的名字. 它的主要特点是
允许一种接近自然语言的证明方法.

我们假设已经有了自然数的加法操作, 满足 \(0 + n = n\),
\(\cons{succ}(m) + n = \cons{succ}(m+n)\). 回忆这里
\(\cons{succ}\) 指的是自然数的后继. 考虑一个自然语言的证明.
\begin{theorem}
对于任何自然数 \(m\), \(m+0 = 0\).
\end{theorem}
\begin{proof}
只需要对 \(m\) 归纳. \(m\) 为 \(0\) 时由于 \(0 + n = n\)
对任何 \(n\) 成立, 代入 \(0\) 即可. 当 \(m\) 为
\(\cons{succ}(m')\) 时, 根据已知条件有
\(\cons{succ}(m') + 0 = \cons{succ}(m'+0)\),
再由归纳假设得到 \(m' + 0 = m'\), 从而命题成立.
\end{proof}

在 Martin-L\"of 类型论中直接写出这个命题的证明是非常长的,
并且写完之后难以阅读. 读者可以尝试一下, 用于检测自己对类型论
的知识是否熟悉. 在 Coq 中提供了\textbf{证明策略}(tactic)的语言,
此时这个命题的证明可以写成
\begin{minted}{coq}
Proof.
  intros m. induction m as [| m' H ].
  - apply add_zero.
  - rewrite add_succ. rewrite H. reflexivity.
Qed.
\end{minted}
这与自然语言几乎完全一致. 第一句话用策略 \texttt{intros}
引入了变量 \(m\), 第二句话对其进行归纳.
这里 \(m'\) 就是在第二种情况下
的变量名, \(H\) 是归纳假设. 接下来的第一种情况
是 \(m = 0\), 此时我们使用一条已知的定理 \texttt{add\_zero},
即 \(0 + n = n\). Coq 自动推断出这里应当取 \(n = 0\).
第二种情况是 \(m = \cons{succ}(m')\), 此时
我们有归纳假设 \(H : m' + 0 = m'\). 我们的目标是
证明 \(\cons{succ}(m') + 0 = \cons{succ}(m')\).
现在我们使用已知的定理 \(\cons{succ}(m') + n = \cons{succ}(m'+n)\)
将等式左侧\emph{改写}, 得到
\(\cons{succ}(m' + 0) = \cons{succ}(m')\).
接下来再使用归纳假设改写得到 \(\cons{succ}(m') = \cons{succ}(m')\).
而这使用等式的自反性即可.

同时, 注意Coq是\emph{交互式}定理证明软件. 在
输入这个证明时, Coq会时刻告诉我们当前这一步有哪些
条件, 目前还有哪些目标. 同时, 我们可以自己编写
强大的自动化证明策略, 如 \texttt{tauto} 策略可以
自动解决命题逻辑的证明(即不涉及\(\forall, \exists\)的操作).
不过需要注意的是, Coq 的核心功能是\emph{检查人类的证明}.
因此它的首要目标是保证检查没有疏漏. 一些其他的软件
目标在于自动化证明尽可能多的命题, 它们的目标不同,
因此是无法相互比较的.

在2005年, Georges Gonthier 等人在 Coq 中完全形式化了
四色定理的证明. 这个定理目前人类所知的证明中涉及到了上千
种情况的讨论, 因此人力几乎不可能保证其正确无误. 在 Coq 形式化
过程中, 也发现了不少对计算机科学有用的图论技巧. 读者可以阅读
发表在《美国数学学会通讯》 (\emph{AMS Notices}) 上的
文章~\cite{gonthier:2008:fourcolor} 中对证明思路与技巧的概述,
只需要高中数学水平, 不需要任何Coq知识.

在计算机领域, Coq也经常用于验证软件代码是否正确.
2009年, Xavier Leroy 等人开发了完全经由 Coq 验证的
代码编译器 CompCert~\cite{leroy:2009:compcert},
证明了这样规模的形式化验证在实践中是可行的.

\subsection{Lean}

Lean 是基于归纳构造演算的通用编程语言与交互式定理证明软件.
它的社区的主要目标是构建一套完整的数学定理库. 为此, 在大部分
时候它都使用了排中律作为公理. 同时, 它也直接将商类型作为
公理加入类型论中. 尽管前文中说过这都会破坏类型论的性质, 但是
由于Lean社区的主要目标不同, 这并不非常重要. Lean社区注重
数学家的使用体验, 因此会对许多使用细节针对性优化. 同时, Lean 也有一套
强大的证明策略语言.

正如文章开头提到的, Lean社区在一年半的时间中, 完成了
Fields奖得主Scholze提出的一个挑战, 证明了Lean在数学领域
的建设是非常成功的. 有本科数学基础的读者如果想要尝试
上手一款定理证明软件, 那么笔者推荐使用 Lean. Coq 与 Agda
对有计算机科学背景的读者更加友好.

\subsection{Agda}

Agda也是基于类似Martin-L\"of类型系统的交互式定理证明
软件. 它尽管也有证明策略语言, 但是主要特征是\textbf{类型驱动开发}.
用户在输入证明时, 可以随时留下一个“洞”. 此时Agda会提示
这个洞需要填入什么类型的表达式, 与当前有哪些可用的条件.
用户可以让Agda执行一些操作修改洞附近的代码, 在这个与
软件合作的过程中逐步完成整个证明. 譬如证明定理
\(\forall n. n + 0 = n\).
\begin{verbatim}
theorem : (n : Nat) -> n + 0 == n
theorem = ?
\end{verbatim}
这里的问号就是待填入的内容. 此时可以使用快捷键
命令Agda引入变量, 它便会自动将代码修改为
\begin{verbatim}
theorem : (n : Nat) -> n + 0 == n
theorem n = ?
\end{verbatim}
接下来, 我们命令Agda对\(n\)归纳, 代码就会变为
\begin{verbatim}
theorem : (n : Nat) -> n + 0 == n
theorem zero = ?
theorem (succ x) = ?
\end{verbatim}
以此类推. 由于这里类型系统强大的表达能力, 我们可以
直接使用类型指导应该填入哪些东西.

Agda实现了非常多前沿的类型论, 如可以开启立方类型论
模式, 就能在立方类型论中进行定理证明. Agda 还支持
自定义公理及其重写规则来模拟全新的类型论. 因此,
Agda 对类型论研究者非常友好, 便于进行实验.

\subsection{其他}

\textbf{逻辑框架}(logical framework) 虽然规则上
大体相似, 但是与上文描述的 Martin-L\"of 类型论
的使用方式风格非常不同. 一个具体的软件实现是Twelf,
主要用于程序验证等.

Nuprl 与 Andromeda 是基于外延类型论的计算机辅助证明软件.
尽管上文中我们说过外延集合论中一个证明是否正确难以机械判定,
但是这些软件中允许用户手动插入额外的说明, 用于帮助软件进行判断.
Sterling、Favonia 等人在 Nuprl 的思想基础上开发了一种
积立方类型论的原型实现 \textsf{{\color{red} Red}PRL}.
